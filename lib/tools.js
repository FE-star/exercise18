/**
 * 文件名称: tools
 * 创建时间: 2018/07/03 11:27
 * 创建用户: Yatoo2018
 * 用户邮箱: tanpf2018@163.com
 * 所属项目: zhenchuanx
 * 项目路径：
 *
 * 修改原因: xxx
 * 修改时间: xxx
 * 修改人名: xxx
 */

var img = /^(?!([img])(?=.*\1))[img]+$/
/*
	需求是 img三个字符不重复，可以随意组合的匹配
	猜想这个正则的思考过程：
	从需求可知，
	1. 我们可选的字符集为img
	写成正则：[img]
	2. 由于3个字符的组合，那么最小的组合1个字符，最长的组合3个字符，那么就可以有1-3
	写成正则：[img]{1,3}
	3. 现在这样选择的字符存在重复 ii, iii的情况，需要排除
		 正则测试，对一个 "已知的字符串" 使用正则进行匹配测试，而测试的过程会是逐个字符的进行正则匹配规则的测试。
		 想到这里，那么我们思考，我们的正则规则中是否存在一个对每一个字符都通用的校验规则，如果存在，那么这样写出来的规则将是最精简的
		 回到我们的需求：
		 三个字符随机组合，但不重复
		 如果没有深思熟虑，我们会有这样的思路，先随机匹配字符集中的随机一个，匹配到之后，
		 然后再从字符集中随机取一个，然后写匹配第二个字符的规则，
		 断言让他和前面随机取到的字符（由于\1具有随机性，所以\2的规则([img])((?<!\1)[img]?),
		 写第3个字符断言的时候不光要保证不和前面重复, 还得断言前面是否匹配到\2，因为写第3个的时候肯定会用到前面的匹配引用，因为要和前面的不重复, 这个可能还得使用更复杂的方案）不重复。
		 ([img])((?<!\1)[img]?)((?<!(\1|\2))[img]?)

		 所以我们的校验规则是不是存在通用的呢？答案是肯定的

	   a. 那么只要我们对这个已知的字符串每一个字符进行我们的规则测试，是否符合我们的规则即可
	   那我们很容易就写一个
	   [img]然后正向断言后面的和前面匹配到的这个字符\1都不重复
	   /^(?!([img])(?=.*\1))[img]+$/

*/